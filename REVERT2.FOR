        program revert2
c       last change/update/compile: Tues. Sept.27,1994 [12:18 p.m.]
c
c		REVERT2.FOR 
c		version 1
c
c 
c	Author: Alexandre Y. Fong, Cirrus Technology Consulting
c				   Copyright 1994
c
c 	A program to calculate cloud 
c	optical extinction and depth 
c	values from simulated lidar returns
c	generated by pgen.for based on the model extinction
c	profiles generated by raygen.for. Can change baseline
c	signal start value for Klett inversion.
c..............................................................
c
c
c	arrays and constants
c
c	cloud base portion:
c
c	sgnl: signal
c	rez: lidar resolution = 40 m
c	sp:log-range adjusted signal 
c	rng: range
c	z: range index
c	npts: number of total range points = 100
c	mpt: how many point fit for cloud base algorithm peak search
c	dpt:how many point fit for cloud base algorithm derrivative
c	xovlp: overlap height, clouds below will not register
c	nob: number of traces to average over for cloud base derivation
c	     ussually = 1	
c	nos: number of shots averaged for this trace = 250
c	gain: i.r. gain setting
c	nd: overall neutral density
c	indx: number of cloud layers not to be confused with indx
c		in the subroutine which is something else!
c	ieb: total number of traces to read
c
c..............................................................
c
c	optical stuff:
c
c	pr:pressure
c	tmp:temperature
c	rh:relative humidity
c	ntot: number of points in sonde data
c	sigref: reference extinction coefficient
c	iref: extinction reference range index
c	k: backscatter/extinction ratio exponent
c	thrush: threshold for diffrence allowed in correlation 
c	algorithm
c	iabove: how many range bins above cloud top to 
c	use as backround for inversion
c..............................................................
c
                real sgnl(100),rng(100),mat(9)
                real logsgnl(100),rezkm,dum 
                real sp(100),mdcldalt,sigp(100)
c		real sum(100),baseline2
		real nd,gain,cldthk(9),mdht(9),plusig
		DIMENSION SIGR(100)
		real z0,zt,sig(100),dep,meanx,sigs(100)
		real rez,krez,k,xovlp,dummy,zero
                real toll,thrush,diff,it,fax,high
                real dpp(3),mnx(3),add
		real pr(20),tmp(20),dew(20),windvel(20)
		real topdep(9),tmeanx(9),slop,bay,htest
		integer windir(20),rh(20),ht(20),nero,pyt
		integer mdcldx,nob,ieb,ll,iabove,mink,inpts
		integer itopx,ibotx,ierp,baseline,cban
                integer*2 jbase(1,6),jtop(1,6),setref
		integer*2 jpeak(1,6),jtrace,n,iwk
		integer mode,indx,kl,li,npts,mpt,dpt,tpt,nlog
		integer*4 i,l,z,iref,ntot      
c		
	real p(100),dp(100),sigma(100),dsigma(100),sigfar,rfar
	integer ifar
                real info(4)
                character*60 lidar,infile,outfile1,outfile2
c
c	open program parameter, file list input and output files
c
		open (unit=8,file='para2.dat',status='old')
		write(*,'(a\)') '\name of lidar file to look at?'
                read(*,'(a)') lidar
		open (unit=10,file=lidar,status='old',form='formatted')
		write(*,'(a\)') '\name of actual extinction file'
		read(*,'(a)') infile
		write(*,'(a\)') '\name of detail output file'
		read(*,'(a)') outfile1
		write(*,'(a\)') '\name of ext profile output file'
		read(*,'(a)') outfile2
		open (unit=11,file=infile,status='old')
		open (unit=12,file=outfile1,status='new')
		open (unit=14,file=outfile2,status='new')
c
c	read program parameters
c
		read(8,*)
		read(8,*) npts,mpt,dpt,tpt,inpts
		write(*,*) npts,mpt,dpt,tpt,inpts
		read(8,*)
		read(8,*) rez,zero,nob,fax,high,nlog
		write(*,*) rez,zero,nob,fax,high,nlog
		read(8,*)
		read(8,*) corrfak,xovlp,ieb,k,setref
		write(*,*) corrfak,xovlp,ieb,k,setref
		read(8,*)
		read(8,*) nd,gain,nos,cban,baseline2
		write(*,*) nd,gain,nos,cban,baseline2
		read(8,*)
		read(8,*) thrush,ntot,iabove,iwk,baseline,add,plusig
		write(*,*) thrush,ntot,iabove,iwk,baseline,add,plusig
c
c
c	set signal registers to zero fill range registers
c
		do 78 i=1,npts
			sgnl(i)=0.00
			sp(i)=0.00
			rng(i)=i*rez
			sig(i)=0.
c		write(11,*) sgnl(i),rng(i)
78		continue
	do 745 i=1,9
	mat(i)=0.
	topdep(i)=0.
	tmeanx(i)=0.
745 	continue
c
c	
c	load lidar data
c	
		do 88 i=1,npts
		read(10,209) rng(i),sgnl(i)
		read(11,209) dum,sigr(i)
209		format(1x,f7.0,1x,e10.3)
88    continue
c	
                        do 79 l=1,npts		
	        if (((baseline.eq.1).and.(sgnl(l).lt.zero)).or.
     +((baseline2.gt.0).and.(rng(l).ge.baseline2))) then
                        sgnl(l)=zero
			else               
                        end if
c	
c	take the log of the signal if you want it!
c		
                logsgnl(l)=alog(sgnl(l)*fax)
                if (logsgnl(l).lt.0) logsgnl(l)=0.
		sgnl(l)=sgnl(l)+add
79              continue
c
		write(*,'(a\)') '\checked for zeros'
c
c 	gain values and technical details
c
		info(1)=nos
		info(2)=rez
		info(3)=gain
		info(4)=nd
		jtrace = 1				
c
c
c..............................................................
c
c	* CLOUD BASE SECTION: write all cloud base data to file unit=11 *
c
c	call cloud base subroutine
c
		if (cban.eq.0) then
		write(*,'(a\)') '\calling cloud base subroutine'
c
	if (nlog.eq.1) then
c
c	log version
c
 		call club(npts,logsgnl,INFO,corrfak,xovlp,
     +              	jbase,jpeak,jtop,jtrace,indx,mpt,dpt)
c
	else
c
c	linear version
c
		call club(npts,sgnl,INFO,corrfak,xovlp,
     +              	jbase,jpeak,jtop,jtrace,indx,mpt,dpt)
c
	end if
c
c 	write to file
c
     		write(12,*) 'number of cloud layers',indx
		if (indx.eq.0) then
		write(12,'(A\)') '\no cloud layers at all!'
	        write(12,747) (mat(i),i=1,9)
		do 7 i=1,3
		dpp(i)=0.
		mnx(i)=0.
		cldthk(i)=0.
		mdht(i)=0.
7		continue
	 	ierp=100
		sigref=sigr(ierp)+plusig			
		goto 187
		else 
		end if
		if (indx.gt.3) then
		write(*,'(A\)') '\more than 3 layers'
		write(*,'(A\)') '\disregrading anything after 3'
		indx=3
		else 
		end if
	else 
		write(12,'(A\)') '\not using cldbase algorithm...'
	        write(12,747) (mat(i),i=1,9)
                do 74 i=1,3
		dpp(i)=0.
		mnx(i)=0.
		cldthk(i)=0.
		mdht(i)=0.
74               continue
	 	ierp=100
		sigref=sigr(ierp)+plusig			
		goto 187
	end if
c
	li=1
	do 746 i=1,indx
	mat(li+i-1)=rng(jbase(1,i))
	mat(li+i)=rng(jpeak(1,i))
	mat(li+i+1)=rng(jtop(1,i))
	li=li+2
746	continue
	do 7746 i=1,indx	
	cldthk(i)=rng(jtop(1,i)-jbase(1,i))
	mdht(i)=rng(((jtop(1,i)-jbase(1,i))/2)+jbase(1,i))
7746	continue
c	
	write(12,*)'cloud base: 1 		2 		3'
     	write(12,747) (mat(i),i=1,9)
747	format(9f7.0)
c
c
c
c..............................................................
c
c	* OPTICAL SECTION:  write all optical data to file unit=16 * 
c
c
c	calculate optical extinction
c	
c	reference extcinction
c
	mink=iabove
112	if (jtop(1,indx)+mink.gt.npts) then 
	mink=mink-1
	goto 112
	else
	end if
	ierp=jtop(1,indx)+mink
c	write(*,*) 'ierp:',ierp
	sigref=sigr(ierp)+plusig
c
c	call inversion subroutines
c
c
c	use Wolfi's Inversion
c
	write(*,*) 'going to invert...'
187	call invert(sgnl,rez,rng(ierp),
     + sigref,sigs,ierp,npts,inpts)
c
        write(*,*) 'Wolf Inversion'
c
c
c	
c	use Klett Inversion
c
	call klett(npts,rng,sgnl,sigref,ierp,rez,
     +k,sig,inpts,mink,zero,high,baseline,setref)
c
	write(*,*)'Klett Inversion'
c
	call slopsig(npts,rez,rng,sgnl,sigp,sigref)
c
	write(*,*)'Slope Inversion'
c
	write(*,*) 'inverted'
	write(*,*) 'calculate optical depth'
c
c	call optical depth subroutine
c
	do 1110 i=1,3
        dpp(i)=0.
        mnx(i)=0.
1110	continue
	if (indx.eq.0) then 
	GOTO 1115
	else
        do 1111 i=1,indx
	z0=rng(jbase(1,i))/1000.
	zt=rng(jtop(1,i))/1000.
	rezkm=rez/1000.
        call opdep(npts,rezkm,z0,zt,sig,dep,meanx)
        dpp(i)=dep
        mnx(i)=meanx
1111    continue
	write(*,*) 'depthed'
	end if
c
c..............................................................
c
c	Truth Inversion Data using ratio method:
c
c	write(*,*)'going to find the truth...'
c
c	call scrat(rez,npts,sgnl,indx,jbase,jtop,topdep,tmeanx,tpt)
c	write(*,*) 'truth found'
c..............................................................
c
c	write outputs to files
c
1115	do 1116 i=1,npts
        write(14,1112) rng(i),sig(i),sigs(i),sigp(i),sgnl(i)
1112	format(f7.0,e10.3,e10.3,e10.3,e10.3)
1116	continue
	write(12,*) 'layer, optical depth, mean extinction'
        write(12,1114) indx,(dpp(i),i=1,3),(mnx(i),i=1,3)
c
c	truthing data file
c
c        write(20,1114) indx,(topdep(i),i=1,3),(tmeanx(i),i=1,3)
c
1114	format(i2,3e10.3,3e10.3)
c.............................................................
	    write(*,'(a\)')'\...It is finally done!'
c
c	close all files
c
		close(8)
		close(10)
		close(11)
		close(12)
		close(14)
c
                stop
                end
c
c..................................................................
c
c	subroutines
c
c...........................................................

	subroutine klett(npts,range,sgnl,sigref,iref,rez,
     +k,sig,inpts,mink,zero,high,baseline,setref)
c		klett.for
c
c		 A simple stable LIDAR aerosol
c		inversion FORTRAN subroutine source code
c		based on J.D. Klett, 15 Jan. 1981/
c		Vol. 20, No: 2/ Applied Optics 
c	
c	npts = number of total points
c	range  = array for range bins
c	sgnl = raw signal array, no correction or logging
c	sigref = refernce extinction value 
c		- calculate from Rayleigh + aerosol model (Shettle & Fenn)
c	iref = index number for reference atmosphere height
c	rez = range bin resolution
c	k = backscatter to extinction ratio constant
c	sig = array with extinction profile
c
c.................................................................
c
c
		real Z,REZ,ZREF,SIGREF,TM1,TM2,SUM,K
		real RANGE(600),SGNL(600)
		real S(600),SIG(600)
		real SIGMIN,SIGMAX
		real X(200),Y(200),ZLIM(6,4),X1(50),Y1(50)
		real SIP(600),ZERO,SREF,div
		CHARACTER*40 TITLE(2),SWITCH,QUE
		INTEGER I,L,IREF,NPTS,inpts,baseline,setref
		INTEGER	 NVEC(6),NZER(6),NSUM,MODE,JOIN,NTOT
c	
c	convert everything to km:
c
	rez=rez/1000.
	do 8 i=1,npts
	range(i)=range(i)/1000.
8 	continue	
c
	sref=0.
	itipl=inpts
	itiph=inpts
24 	if ((iref+itiph).ge.npts) then	        
	itiph=itiph-1
	goto 24
	else 
	end if
	div=(itiph+itipl)*1.+1.
c	div=itiph*1.+1.
	do 57 i = (iref-itipl),(iref+itiph)
	 SREF= SREF +sgnl(i)
	write(*,*) 'hits me!'
57	continue
	if (iref.eq.npts) then 
	sref=sgnl(iref)
	div=1.
	else
	end if
	if (setref.eq.1) then
	sref=zero
	dev=1.
c	else if (div.eq.1) then
c	sref=sgnl(iref)
	else
	end if
	sref=sref/div
	write(*,*) 'iref,div,sref=',iref,div,sref
	s(iref)=alog((sref)*(range(iref)**2))
c
c		Logarithmic Range Adjusted Power
c
		DO 50 I=1,iref-1
			S(I)=ALOG((RANGE(I)**2)*SGNL(I))
50		CONTINUE
c		write(*,*) 'all data logged'
c
c		The Klett inversion
c
888		SUM=0.0
		SIG(IREF)=SIGREF
c		write(*,*) 'calculate terms '
		DO 60 I=IREF-1,1,-1
			TM1=EXP((S(I)-S(IREF))/K)
			TM2=EXP((S(I+1)-S(IREF))/K)
			SUM=SUM+(TM1+TM2)/2.0
c		write(*,*) 'terms calculated-test'
		IF (((1.0/SIGREF)+(2.0*SUM*REZ/K)).EQ.0.) THEN
		SIG(I)=high
		ELSE
c		write(*,*) 'ratio!'
c		write(*,*) tm1
c		write(*,*) ((1.0/SIGREF)+(2.0*SUM*REZ/K)) 
		SIG(I)=TM1/((1.0/SIGREF)+(2.0*SUM*REZ/K)) 
		END IF
60		CONTINUE
c		write(*,*) 'inversion done'
c
c
c	
c	convert  back to m:
c
	rez=rez*1000.
	do 4 i=1,npts
	range(i)=range(i)*1000.
4 	continue	
		return
		end
c
c.................................................................
c
	subroutine scrat(rez,npts,sgnl,nlyr,jbase,jtop,topdep,tmeanx,tpt)
c
c	scrat.for
c
c	Cirrus Technology Consulting 
c	copyright 1994
c
c	Author: Alexandre Y. Fong
c	Last Revision/Compile/Update: June 30, 1994 [1:10 p.m.]
c
c
c.............................................................
c
c	Description:
c
c	This subroutine calculates the optical depth and mean
c	extinction coefficient of cloud signals by taking the
c	ratio of the lidar signal just above and below the clouds
c	de-range correcting dividing it by 2 and logging it.
c
c.............................................................
c
c	Arrays Variables and Constants
c
c	rez: per bin range resolution of data
c	npts: total number of points of data
c	sgnl: array with the signal
c	nlyr: number of cloud layers in this trace
c	jbase(1,*): array with cloud base height indices
c	jtop(1,*): array with cloud top height indices
c	range(100): array with range bins
c	topdep: array with cloud optical depths
c	tmeanx: array with cloud mean optical extinctions
c	tpt: number of points averaged over path
c
	real rez,sgnl(100),topdep(9),tmeanx(9),range(100)
	real rsc,rsq,rsqb,rsqt,opy,prod,topav,basav,div1
	real div2
	integer npts,nlyr,tpt,itt,itb,itest
	integer*2 jbase(1,6),jtop(1,6)
	
c	intialize arrays
c
	do 2 k=1,6
	topdep(k)=0.
	tmeanx(k)=0.
2	continue
	do 3 l=1,npts
c
c	distances in km
c
	range(l)=l*rez/1000.
c	write(*,*) range(l)
3	continue	
c
	if(nlyr.eq.0) then
	goto 9
	else
	end if
	do 1 i=1,nlyr
	basav=0.
	itb=tpt
c	write(*,*)'base-2-lo?'
	if (nlyr.eq.1) then
	goto 8
	else 
7	itest=jbase(1,i)-itb
	if (itest.lt.jtop(1,i-1)) then 
	itb=itb-1
	goto 7
	else
	end if
	end if
c	write(*,*)'truth-base'
8	itest=jbase(1,1)-(itb-1)
	if (itest.le.0) then
	itb=jbase(1,1)
	else
	end if
	do 6 m=1,itb
c	write(*,*)'m=',m
	basav=basav+sgnl(jbase(1,i)-(m-1))
6	continue
	div1=itb
	basav=basav/div1
c	write(*,*)'top-2-hi?'
	topav=0.
	itt=tpt
5	itest=jtop(1,i)+itt
	if (itest.ge.npts) then 
	itt=itt-1
	goto 5
	else
	end if
c	write(*,*)'truth-top...'
	do 4 m=1,itt
	topav=topav+sgnl(jtop(1,i)+(m-1))
4	continue
	div2=itt
c	write(*,*) 'div2=',div2
c	write(*,*)'topav=',topav
c	write(*,*)'looking for truth'
	if (topav.eq.0.) then
	rsc=0.
	else
	topav=topav/div2
	rsc=basav/topav
	end if
	rsqb=(range(jbase(1,i)))**2
	rsqt=(range(jtop(1,i)))**2
	rsq=rsqt/rsqb 
	prod=rsc*rsq
	if (prod.eq.0.) then
	opy=0.
	else
	opy=alog(prod)
	end if
	if (opy.lt.0.) then 
	topdep(i)=0.
	else
	topdep(i)=opy/2.
	end if
	thk=range(jtop(1,i))-range(jbase(1,i))
	if (thk.eq.0.) then
	tmeanx=0.
	else
	tmeanx(i)=topdep(i)/thk	
	end if
1	continue	
c	write(*,*) 'truth found!'
9	return
	end

c......................................................................
c
	subroutine opdep(npts,rezkm,z0,zt,sig,dep,meanx)
c
c	a subroutine to calculate the optical depth and mean cloud extinction
c	from an exitinction profile from a given cloud base and top altitude,
c	vertical resolution and...
c
c	npts = number of data points
c	rez = vertical resolution
c	zmin = overlap altitude of LIDAR
c	z0 = cloud base
c	zt = cloud top
c	sig = extinction profile
c	dep = optical depth
c	meanx = mean cloud extinction (as defined by C.M.R. Platt,
c		Journ.Atmos.Sci. Feb 1987)
c
c	arrays,integers and real variables
c
        real rezkm,z0,zt,sig(600),dep,sum,meanx
	integer npts,i,it,i0
c
	i0=ifix(z0/rezkm)
	it=ifix(zt/rezkm)
c
	dep=0.00
	sum=0.00
c
	do 1 i=i0,it
	sum=sig(i)*rezkm
	dep=dep+sum
1	continue
c
        if ((zt-z0).eq.0) then
	meanx =0.
	else
	meanx=dep/(zt-z0)
	end if
c
	return
	end
c..................................................................
c
c	more subroutines
c..................................................................
c
	SUBROUTINE club(N,P,INFO,corrfak,xovlp,
     +              	jbase,jpeak,jtop,jtrace,k,npt,dpt)
C..................................................................
C
c	subroutine to calculate cloudbase and cloudtop for a single trace
c
c	parameters: integer*2 n = number of data points in the trace
c		    real      p(*) = array containing the lidar backscatter 
c		    		     signal
c	            real info(*) = array containing additional information
c					about the lidar trace, like time, date,
c					neutral-density filter, height-resolution
c
c			info(1) = number of shots averaged for this trace (=fshot)
c			info(2) = resolution
c
c			info(3) = gain
c		         
c			info(4) = overall neutral density
c
c		    real corrfak = faktor that determines the sensitivity of 
c				   algorithm. low corrfak tends to trigger on
c				   noise spikes, high corrfak will not recognize 
c				   weak cloud layers. good values seem to be 
c				   for 150 shot averages and the green signal:
c				      corrfak = 1.4 ... 1.8
c					
c				   and the IR signal :
c	                               corrfak = 0.8 ... 1.2
c
c		    real xovlp = overlap height. signal peaks below the overlap height
c				 will not registre clouds.	
c
c		    integer*2 jbase(600,*),jpeak(600,*),jtop(600,*) the 
c				 	cloudbase algorithm will report the
c				        index of the altitudes (real altitude =
c					= index * height resolution) in these two 
c				        dimensional arrays. since only one trace 
c				        is processed by icb, the integer*2 quantity
c				        jtrace tells icb into which column to store 
c				        the bases and tops for the present trace.
c					jbase(jtrace,1) will contain the index of the 
c					base of the lowest cloud, jbase(jtrace,2) the 
c					index of the next higher cloud and so on.
c					before I use these arrays I fill them up with
c					-1s, since icb only writes the bases it  finds 
c					to the array. therefor jbase(jtrace,level) = 0 means
c					that no base for the level = level was found for trace 
c				        jtrace.
c
c		integer npt = number of point search for peak 
c		integer dpt = number of point fit for derivative fit
c
c		     integer*2 jtrace = number of the trace being processed.
c
c		     integer*2 indx = used to give the plotting coordinate on the 
c				      time axis for the time - altitude plots.
c
c
c		
C................................................................
c
c	arguments passed in parameter list
c
	real p(*),xovlp,corrfak
	integer*2 jbase(1,*),jpeak(1,*),jtop(1,*)
        integer*2 jtrace,mode,iwidth,n
	integer*4 npt,dpt
	real INFO(*)
	integer indx
c
c
	INTEGER*4 	ihelp
	INTEGER		izero(400),ipeak(400),itop(200)
	INTEGER		i,j,k,l,ILAM,fshot
 	REAL		PZERO(400),PPEAK(400),ptop(200)
	REAL		PPRM(2050),f1hlp(509),f2hlp(509),f3hlp(2044)
	real		f4hlp(2044)
        integer*4       i1hlp(3),i2hlp(3),i3hlp(4),i4hlp(4)
        real             xres,nd0,fnd
	
c	common /help2/ f1hlp,f2hlp,f3hlp,f4hlp,i1hlp,i2hlp,i3hlp,i4hlp
c     + 			,izero,ipeak,itop,pzero,ppeak,ptop	
c
c
C..................................................................
c
c	get some information
c
	  xres=info(2)
	  gain=info(3)
	  nd0=info(4)
	  fshot=info(1)	
	  fnd=nd0
c
c.....................................................................
c	get the first derivative of the signal using a dpt point 
c	least squares linear fit
c
c	  p(1)=p(2)
c
	call difflin(p,xres,n,pprm,dpt)
c
c
C------------------------------------------------------------------
C  --- Check on Zero Crossing---------------
C------------------------------------------------------------------
c
	K=0
	ibgn=xovlp/xres
c	old
	IEND=n-1
c	new
c	IEND=n
	npt2=npt/2
c
c	*SLOWPITCH*
c	
	DO 120 I=IBGN,IEND
c	original
c	  IF((PPRM(I).LT.0.0).AND.(PPRM(I+1).GE.0.0)) then
c	my way
	  IF((PPRM(I).le.0.0).AND.(PPRM(I+1).gt.0.0)) then
c
c	that's a base candidate
c
	if(k.gt.400) then
	write(*,*) 'stop idiot!',k
	stop
	else
	ENDIF
	    k=k+1
	    pzero(k)=p(i) 
	    izero(k)=i
c
c	if there is a smaller value in the neighbourhood-
c	thats the better base-candidate
c 
	    do 100 j=max0(ibgn,i-npt2),min0(iend,i+npt2)
	      if (p(j) .lt. pzero(k)) then 
		pzero(k)=p(j)
	        izero(k)=j
	      endif
100	    continue      
	  ENDIF
c
c........................................................................
c
	if (k.gt.400) then
	write(*,*) 'STOP STUPID!',k
	stop
	else
	endif   
	    ipeak(k)=izero(k)
	    ppeak(k)=pzero(k)
c........................................................................
c	now look for the next peak
c
	    do 11110 jj=izero(k),iend
	      IF((PPRM(jj).GT.0.0).AND.(PPRM(jj+1).LE.0.0))then
c
c	that's a peak candidate
c
	        ppeak(k)=p(jj+1) 
	        ipeak(k)=jj+1
c
c	if there is a higher value in the neighbourhood-
c	however after the corresponding base candidate
c	thats the better peak-candidate
c 
	        do 110 j=izero(k)+1,min0(iend,jj+1+npt2)
	          if (p(j) .gt. ppeak(k)) then 
		    ppeak(k)=p(j)
	            ipeak(k)=j
	          endif
110	        continue      
	        goto 119
	      ENDIF
11110	    continue
c		new	
119	  if (k .ge. 400) goto 130
c
120	CONTINUE
	goto 135 
c
130	pause 'more than 400 base candidates found'
c
135	IF(K.EQ.0) GOTO 80
c
C
c...................................................................
C	Reject all insignificant peaks and corresponding zero crossins 
C
	  fak=sqrt(87./fshot/xres*(10.**fnd))*1.16
c
	DO 200 J=1,K
 	    REJECT=PPEAK(J)
	    REJECT=SQRT(REJECT)*FAK*corrfak
	    if (izero(j) .lt. nint(4000./xres)) reject=reject*2.0
	    if (izero(j) .lt. nint(2000./xres)) reject=reject*1.5	 
c
c	mark the base and peak candidates to be rejected
c
	  DIFF= PPEAK(J)-PZERO(J)
	  IF (DIFF.le.REJECT) then
c
c	  single peak less than reject might be thrown away
c
	    diff21 = p(ipeak(j)-1) - pzero(j)
	    diff22 = p(ipeak(j)+1) - pzero(j)
	    reject = reject/1.5
c
c	   unless the single peak and a neighbour-point are
c	   larger than a reduced reject
c
	    if ((diff .gt. reject).and.((diff21.gt.reject).or.
     +                                  (diff22.gt.reject))) goto 200 	
	    diff31 = p(ipeak(j)-2) - pzero(j)
	    diff33 = p(ipeak(j)+2) - pzero(j)
	    reject = reject/1.22
c
c	   or unless the single peak and two neighbours are
c	   larger than an even further reduced reject 
 	    
	    if ((diff .gt. reject).and.
     +	        (((diff31.gt.reject).and.(diff21.gt.reject)).or.
     +		 ((diff22.gt.reject).and.(diff33.gt.reject)))) goto 200
c
c	   now it has to be rejected
c 
	    	izero(j)=-1
c
	  endif
c
200	CONTINUE
c
c....................................................................
c	now throw all the bad candidates away
c
	j=1
202	  if (izero(j).eq.-1) then
c	throw the j.th point away, shift all other points left,
c	after that look at the j.th point (now new,because shifted) again	
	    k=k-1
	    call wshift(izero,pzero,j,k,1)
	    call wshift(ipeak,ppeak,j,k,1)
	  else
c	look at the next point
	   j=j+1
	  endif
c
c	the thing is finished when we have looked at the k.th point
c
	if (j.le.k) goto 202
c	
	if (k .le. 0) goto 80
c
c...................................................................
c
C-----------------------------------
C   Determine cloud top
C-----------------------------------
c
	pback=0.
	pback=p(2043)
	j=1
4999        do 5100 i=ipeak(j),n
c
c	    thats the simplest cloud top: signal at top <= signal at bottom 
c
	      if (p(i) .le. pzero(j)) then
	        itop(j)=i
	        ptop(j)=p(i)
cc	        write (*,'(a\)') ' top found for candidate',j,'itop=',i 
cc	        write (8,*) ' top found for candidate',j,'itop=',i 
c
c	    it is better if we can find a top were p(top) <= p(base) range 
c								 corrected
c 
	        if (i*xres .lt. 7000) then
	        do 5110 l=i+1,min0(n,i+nint(600./xres))
  		  rcorr=float(izero(j))/float(l)
		  rcorr=rcorr*rcorr
	          if (p(l) .le. (pzero(j)*rcorr+pback*(1.-rcorr))) then
	            itop(j)=l
	            ptop(j)=p(l)
CC	            write (*,'(a\)') ' range corrected',j,'itop=',l 
cc	            write (8,*) ' even better',j,'itop=',l 
		    goto 5120		              
	          endif
5110		continue	
	        endif 
5120	        j=j+1
	        goto 5000
	      endif
	      if (i .eq. n) then
cc	        write (*,'(a\)') ' no top found for candidate',j
cc	        write (8,*) ' no top found for candidate',j
c
c	throw the candidate away, shift the rest 
	        k=k-1
	        call wshift(izero,pzero,j,k,1)
	        call wshift(ipeak,ppeak,j,k,1)
	      endif
5100	  continue 
5000	if (j .le. k) goto 4999
c
c	now make shure to get the highest top of all bases in the same 
c	cloud
c
	j=1
3003	ishift=0	
	do 4000 i=j+1,k
	  if (izero(i) .le. (itop(j)+nint(100./xres))) then
	    if (itop(i) .gt. itop(j)) then
		itop(j)=itop(i)
	        ptop(j)=ptop(i)
	    endif 	
	    ishift=ishift+1
	  endif
4000	continue
	if (ishift .gt. 0) then
c
c	throw these ishift points away, shift all other points left,
c
cc	write (*,'(a\)') 'ishift=',ishift
cc	write (8,*) 'ishift=',ishift
	    k=k-ishift
	    call wshift(izero,pzero,j+1,k,ishift)
	    call wshift(ipeak,ppeak,j+1,k,ishift)
	    call wshift(itop,ptop,j+1,k,ishift) 
	endif
c
c	look at the next point
c
	   j=j+1
c
c	the thing is finished when we have looked at the k.th point
c
	if (j.le.k) goto 3003
c
c.........................................................................
c	find the maximum signal from the cloud
c
	do 4114 j=1,k
	  peak=ppeak(j)
	  imerk=ipeak(j)
	  do 4224 jj=izero(j),itop(j)
	    if (p(jj) .gt. peak) then
              peak=p(jj)
	      imerk=jj
	    endif
4224	  continue
	  ppeak(j)=peak
	  ipeak(j)=imerk
4114	 continue 	
c
c	now lets write the stuff to the cloudbase file
c
	if (k .gt. 6) stop 'icb cannot handle than more than 6 layers'
	DO 4230 J=1,k
	  jbase(jtrace,j)=izero(j)
	  jpeak(jtrace,j)=ipeak(j)
	  jtop(jtrace,j)=itop(j)
c 	  WRITE(11,370) J,izero(J)*xres,pzero(J),itop(j)*xres,ptop(j),      
c     +			ipeak(j)*xres,ppeak(j)
cc 	  WRITE(11,370) J,izero(J)*xres,pzero(J),itop(j)*xres,ptop(j)
4230	CONTINUE
c
c80     WRITE(11,390)
80	WRITE(*,391)
c80       WRITE(*,390)
C-------------------------------------------------------
C	FORMAT STATEMENTS
C............................................................
 300	FORMAT ('@Time:',i6,'Date:',i6,'lambda',
     +	i5,'ND',f4.1,'gain',f5.1,'NPT',i3,'@') 
 310	FORMAT(I5,F12.5,2E15.5)
 320	FORMAT('             ALL  ZERO CROSSING IN dP/dr' )
 330	FORMAT(' Index  Rbase [m]   Pbase       Rtop [m]    Ptop
     +	Rpeak [m]  Ppeak')
 340	FORMAT(2I6,E12.5,i6,E12.5)
 350	FORMAT('    Main zero crossings and cloud peaks ')
 370	FORMAT(I6,6E12.5)
 380	FORMAT('    Cloud bases of separate layers only ')
 390	FORMAT('   NO CLOUD DETECTION')
 391	FORMAT('   TICK')
395 	format('@ymin=',e12.5,'ymax=',e12.5,'@')	
C-----------------------------------------------------
 400	CONTINUE
	RETURN
	END
c
c	more SUBROUTINES.....................................
c
c
	subroutine wshift (iarr,parr,j,k,ishift)
c
c	this subroutine shifts in the arrays iarr(integer*2)
c	and parr(real) all data points left. 
c	data point j+ishift is shifted into j
c       .....
c	data point k+ishift is shifted into k
c
c	data points with index < j are not affected.
c	data points with j =< index < j+index are lost.
c
c	! make shure k+ishift does not exceed the array-size ! 	 
c
	integer iarr(*),j,k,ishift
	real parr(*)
c
 	do 200 l=j,k
	  iarr(l)=iarr(l+ishift)
	  parr(l)=parr(l+ishift)
200	continue
c
	return
	end

c
c....................................................................
c
	subroutine olinfit(fdat,dx,n,icenter,iwidth,iold
     +	  ,fx,fy,fx2,fxy,a,b)
c
c	fits a straight line a*i*dx+b through the data points given by
c	the coordinates fdat(i),i*dx. fdat(1..n) is a real-array. 
c	the line is fitted through the data points iwidth to the left
c	and to the right of icenter. 		
c	iold is used to reduce the amount of calculations considerably
c	if the linear fit has already been performed before to a partly
c	overlapping set of data-points.
c	in this case the sums fx,fy,fx2,fxy are just modified and have 
c	to be used as input parameters.
c	a,b are the coefficients of the linear fit.
c
c	NOTE : THIS ALGORITHM HAS SHOWN NUMERICAL PROBLEMS. THIS COMES
c	FROM THE LARGE NUMBER OF SUBTRACTIONS AND ADDITIONS. IT SEEMS THAT
c	ADDING AND SUBTRACTING THE SAME SMALL NUMBER TO A LARGE SUM 
c	DOES NOT LEAVE THE SUM UNCHANGED      
c
	real fdat(*),dx,fx,fy,fx2,fxy,a,b
	integer icenter,iold
        integer iwidth
	integer*2 n
c
c
	ileft=max0(1,icenter-iwidth)
	iright=min0(icenter+iwidth,n)
	di=iright-ileft+1 
	if (di .le. 1) goto 999
c
c	evaluate sum xi = dx (ileft+(ileft+1)+ .... +iright)
c
 	fleft=float(ileft)
	fhelp=fleft*(fleft-1.)/2.
	fright=float(iright)
	fhelp2=fright*(fright+1.)/2.
	fx=dx*(fhelp2-fhelp)
c
c	evaluate sum xi^2 = dx^2 (ileft^2+(ileft+1)^2+ .. +iright^2)
c
	fhelp=fhelp*(2.*fleft-1.)/3.
	fhelp2=fhelp2*(2.*fright+1.)/3.
	fx2=dx*dx*(fhelp2-fhelp)
c
	if (iold .eq. 0) then
c
c	reset the other things
c	
	  fy=0.
	  fxy=0.
	  iold=-icenter-iwidth
	  goto 305
	endif
c
c	if something is known already its less work
c
c
c	evaluate the sum yi = y(ileft)+y(ileft+1)+ .. y(iright)
c	  and the sum xi*yi = dx*(ileft*y(ileft)+ .. +iright*y(iright))
c	 and the other sums 
c
 	if ((iold+iwidth) .le. icenter) then
cc	  write (*,'(a\)') ' resetting the sums'
	  fy=0.
	  fxy=0.
	  iold=-icenter-iwidth
	  goto 305
	endif
	if (icenter.le. (iold-iwidth)) then
cc	  write (*,'(a\)') ' resetting the sums'
	  fy=0.
	  fxy=0.
	  iold=-icenter-iwidth
	  goto 305
	endif
	do 100 i=max0(1,iold-iwidth),ileft-1
cc	  write (*,'(a\)') ' subtracting point ',i
	  fhelp=fdat(i)
	  fy=fy-fhelp
	  fxy=fxy-i*dx*fhelp            
100	continue
105	do 200 i=ileft,min0(iold-iwidth-1,iright)
cc	  write (*,'(a\)') ' adding point ',i
	  fhelp=fdat(i)
	  fy=fy+fhelp
	  fxy=fxy+i*dx*fhelp            
200	continue
	do 300 i=iright+1,min0(iold+iwidth,n)
cc	  write (*,'(a\)') ' subtracting point ',i
	  fhelp=fdat(i)
	  fy=fy-fhelp
	  fxy=fxy-i*dx*fhelp            
300	continue
305	do 400 i=max0(iold+iwidth+1,ileft),iright
cc	  write (*,'(a\)') ' adding point ',i
	  fhelp=fdat(i)
	  fy=fy+fhelp
	  fxy=fxy+i*dx*fhelp            
400	continue
c
c	calculate the a and b
c
cc	write (*,*) ' fx=',fx
cc	write (*,*) ' fx2=',fx2
cc	write (*,*) ' fy=',fy
cc	write (*,*) ' fxy=',fxy
	fhelp=(di*fx2-fx*fx)
	if (fhelp .eq. 0.0) fhelp=1.e-35
	a=(di*fxy-fx*fy)/fhelp
	b=(a*fx-fy )/di
	iold=icenter
c
	return
999	pause 'cannot fit a line with only 1 data point'
	return
	end
c
c...................................................................
c
	subroutine difflin(fdat,dx,n,fdiff,iwidth)
c
c	takes the derivative df/dx of the function given by 
c	f(xi)=fdat(i) , xi=i*dx.
c	to get the derivative a straight line is fitted through the
c	data points iwidth to the left and the right of the point 
c	where the derivative is to be taken.
c	fdat(1..n) = array containing the values
c	dx = increase in x value for increasing the index
c	fdiff(1..n) = array returning the derivative
c	iwidth = width of the fit
c
	real fdat(*),fdiff(*),dx
	integer iwidth
        integer*2 n
c
	real fx,fy,fx2,fxy,a,b
	integer iold,i
c
	iold=0
	do 100 i=1,n
cc	 call olinfit(fdat,dx,n,i,iwidth,iold,fx,fy,fx2,fxy,a,b)
	 call linfit(fdat,dx,n,i,iwidth,a,b)
	 fdiff(i)=a
cc	 write (*,*) ' i,fdiff(i)',i,fdiff(i) 
100	continue
c
	return
	end
c
c....................................................................
c
	subroutine linfit(fdat,dx,n,icenter,iwidth,a,b)
c
c	fits a straight line a*i*dx+b through the data points given by
c	the coordinates fdat(i),i*dx. fdat(1..n) is a real-array. 
c	the line is fitted through the data points iwidth to the left
c	and to the right of icenter. 		
c	a,b are the coefficients of the linear fit.
c
c
	real fdat(*),dx,a,b
	integer icenter
	integer iwidth
        integer*2 n
c
c
	ileft=max0(1,icenter-iwidth)
	iright=min0(icenter+iwidth,n)
	di=iright-ileft+1 
	if (di .le. 1) goto 999
c
c	reset the other things
c	
	  fx=0.
	  fx2=0.
	  fy=0.
	  fxy=0.
c
c	evaluate the sum yi = y(ileft)+y(ileft+1)+ .. y(iright)
c	  and the sum xi*yi = dx*(ileft*y(ileft)+ .. +iright*y(iright))
c	 and the other sums 
c
105	do 200 i=ileft,iright
cc	  write (*,*) ' adding point ',i
	  fx=fx+i
	  fx2=fx2+float(i)*i 	
	  fhelp=fdat(i)
	  fy=fy+fhelp
	  fxy=fxy+i*fhelp            
200	continue
c
c	calculate the a and b
c
cc	write (*,*) ' fx=',fx
cc	write (*,*) ' fx2=',fx2
cc	write (*,*) ' fy=',fy
cc	write (*,*) ' fxy=',fxy
	fhelp=(fx*fx-di*fx2)*dx
	if (fhelp .eq. 0.0) fhelp=1.e-15
	a=(fx*fy-di*fxy)/fhelp
	b=(fy-dx*a*fx)/di
c
	return
999	pause 'cannot fit a line with only 1 data point'
	return
	end
c
c.........................................................................
c
c--------------------------------------------------------------------------
c
	subroutine invert(p,res,rfar,sigfar,sigma,ifar,npts,inpts)
c
c	subroutine invert(p,dp,res,rfar,sigfar,sigma,dsigma,ifar)
c
c	***MODIFIED by Cirrus Technology Consulting for KNMI
c
c	does a simple far end (klett) inversion, using the k-value k = 1 in 
c	the relation beta(r)=C*sigma(r)^k. The standart deviation of the 
c	sigma profile is estimated using the standart deviation of the signal
c	and gaussian error analysis.
c	Signal values less than zero are forced to zero.
c
c	input parameters : p = array containing the backscattered power, 
c			       background subtracted, but not range corrected
c			       and/ or log-ged.
c			   dp = array containing the standart deviation 
c				of the signal 
c			   res = range resolution [m]
c			   sigfar = far end starting sigma [1/km]
c			   rfar = far end distance [m]
c			inpts = number of point averaage of signal above cloud
c
c	output parameters : sigma = array containing the sigma profile [1/km]
c			    dsigma = array containing estimated standart 
c				     deviation of sigma	
c			    ifar = array index corresponding to the far end
c				   range
c
        real p(*),sigma(*)
c        real dsigma(*),dp(*)
        real sigfar,rfar
	integer ifar,inpts
c
	real pff,sum,sum2,pfold,sig2far,div
c
c	
	ifar = nint(rfar/res)
c	write(*,*) 'rfar,ifar',rfar,ifar
	pff = 0.
c
c	do 50 i = ifar-5,ifar+5
c50	pff = pff +p(i)
2	div=abs(inpts)*1.+1.
c	write(*,*) 'div=',div
        if ((ifar+inpts).ge.npts) then
	inpts=inpts-1
	goto 2
	else 
	end if
	do 50 i = ifar,ifar+inpts
50	pff = pff +p(i) 

c	far end range corrected power

C	force pff >= 0.
	if (pff .lt. 0.) pff=0.
51      pff = (pff/div)*ifar*ifar
c
c	terms for error analysis
c	
c        if (p(ifar) .ne. 0.) then
c          dx=dp(ifar)/p(ifar)/sqrt(11.)
c        else
c          dx=dp(ifar)/1.e-10/sqrt(11.)
c        endif
c        dy = ifar*ifar*dp(ifar)/sigfar/sqrt(11.)
c        sumz = ifar*ifar*dp(ifar)*dp(ifar)
c        dz = sumz*4.
c
c	terms for sigma calculation
c
	reskm = res/1000.
	sigma(ifar) = sigfar
	sum2 = 0.
	pr2old = pff
	sig2far = pff/sigfar
c
c        dsigma(ifar) = sigma(ifar)*sqrt(dx*dx+
c     +              (dy*dy+dz)/sig2far/sig2far)
c
	do 200 i = ifar-1,1,-1
c
c	that is to calculate the sigma
c
	   pff = p(i)*i*i
c	force pff >= 0.
	   if (pff .lt. 0.) pff = 0.
	   sum2 = sum2 + (pff+pr2old)*reskm
	   if ((sig2far + sum2).eq.0) then
	   sigma(i)=0.
	   goto 54 
	   else
	   end if
	   sigma(i) = pff/(sig2far + sum2)
54	   pr2old = pff
c
c	   write (*,*) i*res,sigma(i)
c
c	that is to calculate the standart deviation of the sigma
c
c           if (p(i) .ne. 0.) then
c             dx=dp(i)/p(i)
c           else
c             dx=dp(i)/1.e-10
c           endif
c           sumz=sumz+i*i*dp(i)*dp(i)
c           dz = 4.*sumz/(ifar-i+1)
c           dsigma(i) = sigma(i)*sqrt(dx*dx+
c     +              (dy*dy+dz)/(sig2far+sum2)/(sig2far+sum2))
c
200	continue
c
	return
	end
c
c.......................................................................
c
	subroutine slopsig(npts,rez,rng,sgnl,sig,sig0)
c
c	slopsig.for
c
c	program to invert lidar returns
c	for volume extinction coefficients (1/km)
c	using the slope method
c
c	rez: height resolution in metres
c	rng: array with range
c	sgnl:  "    "   signal
c	sig:   "    "   sigmas that are returned
c	npts: number of data points
c	sig0: reference extinction value at npts
c
c	arrays and variables
c	
	real rng(100),sgnl(100),S(100),sig(100)
	real sig0,rez
	integer npts
c
c	inversion
c
	sig(1)=sig0
	S(npts)=alog(((rng(npts)/1000.)**2)*sgnl(npts))	
	do 1 i=npts-1,1,-1
	S(i)=alog(((rng(i)/1000.)**2)*sgnl(i))
	sig(i)=(S(i+1)-S(i))/(-2.0*(rez/1000.))
1	continue
c
c	end
c
	return
	end

c
c.................................................................
c
